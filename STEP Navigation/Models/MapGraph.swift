//
//  FirebaseManager.swift
//  STEP Navigation
//
//  Created by Paul Ruvolo on 3/30/23.
//

import Foundation
import FirebaseCore
import FirebaseDatabase
import ARKit
import FirebaseStorage
import SwiftGraph

/// A pair of nodes suitable for specifying the start and end of an edge
struct NodePair<T: Hashable, U: Hashable>: Hashable {
    /// The start of the edge
    let from: T
    /// The end of the edge
    let to: U
}

/// Simple edges contain a identifier that allows for downloading and constructing a ``ComplexEdge``.  The simple edge only defines cost, rather than the actual sequence of poses that are specified in a ``ComplexEdge``.
struct SimpleEdge {
    /// The identifier of the edge (suitable for downloading the full path)
    let pathID: String
    /// The cost of traversing the edge (currently based on the length of the path)
    let cost: Float
}

/// A complex edge that allows for multiple paths to be stitched together into a single, unified path.
struct ComplexEdge {
    /// The pose of the start of this edge (this will coincide with a cloud anchor)
    let startAnchorTransform: simd_float4x4
    /// The pose of the end of this edge (this will coincide with a cloud anchor)
    let endAnchorTransform: simd_float4x4
    /// The sequence of poses that make up the path itself (excluding the start and end anchor)
    let path: [simd_float4x4]
    /// Any cloud anchors (cloud identifier is the key) and anchor poses (values) that were created while recording this path.
    let pathAnchors: [String: simd_float4x4]
    
    /// The length of the path measured in meters.
    var cost: Float {
        if let first = path.first, let end = path.last {
            var d: Float = 0.0
            
            // add the cost of moving from start anchor to the beginning of the path
            d += simd_distance(startAnchorTransform.columns.3, first.columns.3)
            
            // add the cost along the path itself
            for (from, to) in zip(path[0..<path.count-1], path[1...]) {
                d += simd_distance(from.columns.3, to.columns.3)
            }
            
            // add the cost of moving from end of the path to the end anchor
            d += simd_distance(end.columns.3, endAnchorTransform.columns.3)
            return d
        } else {
            return simd_distance(startAnchorTransform.columns.3, endAnchorTransform.columns.3)
        }
    }
}

/// This class encompasses a map consisting of cloud anchors (nodes) and paths connecting cloud
/// anchors (edges).  This class is mainly a datastructure and other classes access its data for
/// performing operations (e.g., path planning)
class MapGraph {
    /// The cloud anchors that compose this graph (the cloud identifier is stored in the set)
    var cloudNodes = Set<String>()
    /// These connections are composed of starting and ending cloud anchors (keys) and
    /// simple edges (values).  These connections can be used for path planning even when
    /// the full connections have not downloaded yet.
    private (set) var lightweightConnections: [NodePair<String, String>: SimpleEdge] = [:]
    /// These connections are comprised of starting and ending cloud anchors (keys) and
    /// complex edges (values).  These connections are useful for constructing the full path
    /// which can then be converted into ``KeypointInfo`` objects.
    private (set) var connections: [NodePair<String, String>: ComplexEdge] = [:]
    
    /// This private Boolean trakcs whether the weighted graph should be recomputed or not
    private var isDirty: Bool = false
    
    /// This object is used to cache the weighted graph that was last generated by this class
    private var cachedWeightedGraph: WeightedGraph<String, Float>?
    
    /// The `SwiftGraph` version of the map graph.  This graph is recomputed only when the underlying data
    /// has changed.
    var weightedGraph: WeightedGraph<String, Float> {
        if !isDirty, let currentGraph = cachedWeightedGraph {
            return currentGraph
        }
        return makeWeightedGraph()
    }
    
    /// Reset the data
    func reset() {
        cloudNodes = Set<String>()
        connections = [:]
        isDirty = false
        lightweightConnections = [:]
    }
    
    /// Print the edges in the graph
    func printEdges() {
        for key in connections.keys {
            print(key.from, key.to)
        }
    }
    
    /// Add the specified cloud anchor node
    /// - Parameter node: the cloud anchor identifier
    func add(node: String) {
        isDirty = true
        cloudNodes.insert(node)
    }
    
    /// Add a new lightweight connection to the graph.
    /// - Parameters:
    ///   - fromID: the starting cloud anchor's cloud identifier
    ///   - toID: the ending cloud anchor's cloud identifier
    ///   - simpleEdge: the simple edge that encodes that path ID and the edge cost
    func addLightweightConnection(from fromID: String, to toID: String, withEdge simpleEdge: SimpleEdge) {
        isDirty = true
        lightweightConnections[NodePair(from: fromID, to: toID)] = simpleEdge
        // add reverse edge if it doesn't exist yet
        if lightweightConnections[NodePair(from: toID, to: fromID)] == nil {
            let reversed = SimpleEdge(pathID: simpleEdge.pathID,
                                      cost: simpleEdge.cost)
            lightweightConnections[NodePair(from: toID, to: fromID)] = reversed
        }
    }
    
    /// Add a new connection to the graph.
    /// - Parameters:
    ///   - fromID: the starting cloud anchor's cloud identifier
    ///   - toID: the ending cloud anchor's cloud identifier
    ///   - complexEdge: the complex edge that encodes that path and start and end anchors
    func addConnection(from fromID: String, to toID: String, withEdge complexEdge: ComplexEdge) {
        isDirty = true
        connections[NodePair(from: fromID, to: toID)] = complexEdge
        // Add the reverse edge if none exists yet.  If we have an actual reverse edge than this would not run
        if connections[NodePair(from: toID, to: fromID)] == nil {
            connections[NodePair(from: toID, to: fromID)] = ComplexEdge(startAnchorTransform: complexEdge.endAnchorTransform,
                            endAnchorTransform: complexEdge.startAnchorTransform,
                            path: complexEdge.path.reversed(),
                            pathAnchors: complexEdge.pathAnchors)
        }
    }
    
    /// Creates the weighted graph (SwiftGraph) from the currently recorded nodes and edges.
    /// Note: this doesn't auto update with Firebase changes
    /// - Returns: the weighted SwiftGraph
    private func makeWeightedGraph()->WeightedGraph<String, Float> {
        let currentLatLon = PositioningModel.shared.currentLatLon ?? CLLocationCoordinate2D(latitude: 0.0, longitude: 0.0)
        let nodes = FirebaseManager.shared.mapGraph.cloudNodes + ["outdoors"]
        let edges = FirebaseManager.shared.mapGraph.lightweightConnections
        let anchorGraph = WeightedGraph<String, Float>(vertices: Array(nodes))
        for (nodeInfo, edgeInfo) in edges {
            guard nodes.contains(nodeInfo.from), nodes.contains(nodeInfo.to) else {
                continue
            }
            anchorGraph.addEdge(from: nodeInfo.from, to: nodeInfo.to, weight: edgeInfo.cost, directed: true)
        }
        let indoorLocations = DataModelManager.shared.getAllIndoorLocationModels()
        
        for indoorLocation in indoorLocations {
            if let cloudID = indoorLocation.getCloudAnchorID(),
               let associatedOutdoorFeature = indoorLocation.getAssociatedOutdoorFeature(),
               let searchLatLon = DataModelManager.shared.getLocationDataModel(byID: associatedOutdoorFeature) {
                anchorGraph.addEdge(from: "outdoors", to: cloudID, weight: Float(currentLatLon.distance(from: searchLatLon.getLocationCoordinate())), directed: true)
            }
        }
        isDirty = false
        cachedWeightedGraph = anchorGraph
        return anchorGraph
    }
}
